datasource db {
  provider   = "postgresql"
  extensions = [pgvector(map: "vector")]
}

generator client {
  provider        = "prisma-client"
  output          = "../src/generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
  runtime         = "bun"
}

generator json {
  provider = "prisma-json-types-generator"
}

model User {
  id         String  @id @default(uuid(7)) @db.Uuid
  telegramId BigInt  @unique @map("telegram_id")
  username   String? @unique
  firstName  String  @map("first_name")
  lastName   String? @map("last_name")
  isActive   Boolean @default(true) @map("is_active")
  isBot      Boolean @default(false) @map("is_bot")
  isPublic   Boolean @default(false) @map("is_public")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  tweets      Tweet[]
  photos      Photo[]
  videos      Video[]
  chatMembers ChatMember[]

  @@map("users")
}

model Chat {
  // Telegram ID
  id       BigInt  @id
  title    String?
  username String?

  photoThumbnail String? @map("photo_thumbnail")
  photoBig       String? @map("photo_big")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  messages    Message[]
  chatMembers ChatMember[]

  @@map("chats")
}

model ChatMember {
  chatId BigInt @map("chat_id")
  userId String @map("user_id") @db.Uuid

  status String

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([chatId, userId])
  @@index([userId])
  @@index([status])
  @@map("chat_members")
}

model Tweet {
  id     String
  userId String @map("user_id") @db.Uuid

  /// [TweetType]
  tweetData Json @map("tweet_data")

  // Virtual columns, manually generated in SQL migration
  tweetText String? @default(dbgenerated()) @map("tweet_text") @db.Text
  username  String? @default(dbgenerated()) @map("username") @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  photos Photo[]
  user   User    @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@id(name: "tweetId", [id, userId])
  @@index([userId, createdAt(sort: Desc)])
  @@index([tweetText])
  @@index([username])
  @@map("tweets")
}

model Photo {
  // Twitter ID
  id             String
  tweetId        String  @map("tweet_id")
  userId         String  @map("user_id") @db.Uuid
  s3Path         String? @map("s3_path")
  originalUrl    String  @map("original_url")
  perceptualHash String? @map("perceptual_hash")

  /// [ClassificationType]
  classification Json? @map("classification")

  imageVec Unsupported("vector(1024)")? @map("image_vec")
  tagVec   Unsupported("vector(1024)")? @map("tag_vec")

  height Int? @map("height")
  width  Int? @map("width")

  // Generated hash bucket columns for similarity search
  hashBucket4  String? @default(dbgenerated()) @map("hash_bucket_4")
  hashBucket8  String? @default(dbgenerated()) @map("hash_bucket_8")
  hashBucket12 String? @default(dbgenerated()) @map("hash_bucket_12")

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  // Relations
  tweet Tweet @relation(fields: [tweetId, userId], references: [id, userId], onDelete: Restrict)
  user  User  @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@id(name: "photoId", [id, userId])
  @@index([tweetId])
  @@index([perceptualHash])
  @@index([hashBucket4])
  @@index([hashBucket8])
  @@index([hashBucket12])
  @@index([s3Path])
  @@index([deletedAt])
  @@index([createdAt(sort: Desc)])
  @@map("photos")
}

model Video {
  id     String @id @default(uuid(7)) @db.Uuid
  userId String @map("user_id") @db.Uuid

  tweetId   String  @map("tweet_id")
  tweetText String? @map("tweet_text") @db.Text

  telegramFileId       String @map("telegram_file_id")
  telegramFileUniqueId String @map("telegram_file_unique_id")

  width  Int?
  height Int?

  description String? @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([telegramFileUniqueId, userId])
  @@index([userId])
  @@index([tweetId])
  @@map("videos")
}

model Message {
  id        String @id @default(uuid(7)) @db.Uuid
  messageId Int    @map("message_id")
  chatId    BigInt @map("chat_id")

  // Sender info
  fromId        BigInt? @map("from_id")
  fromUsername  String? @map("from_username")
  fromFirstName String? @map("from_first_name")

  // Message content
  text    String? @db.Text
  caption String? @db.Text

  // Entities for LLM context
  /// [MessageEntitiesType]
  entities        Json? @map("entities")
  /// [MessageEntitiesType]
  captionEntities Json? @map("caption_entities")

  // Media type: photo, video, document, audio, voice, video_note, sticker, animation, poll, etc.
  mediaType String? @map("media_type")

  // Threading / Reply context
  replyToMessageId Int? @map("reply_to_message_id")
  messageThreadId  Int? @map("message_thread_id")

  // Forward origin as JSON
  /// [ForwardOriginType]
  forwardOrigin Json? @map("forward_origin")

  // Full raw message for complete data preservation (LLM processing)
  /// [TelegramMessageType]
  rawData Json @map("raw_data")

  // Telegram timestamps
  date     DateTime  @map("date")
  editDate DateTime? @map("edit_date")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  // Relations
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@unique([messageId, chatId])
  @@index([chatId, date(sort: Desc)])
  @@index([fromId])
  @@index([mediaType])
  @@index([text])
  @@index([deletedAt])
  @@map("messages")
}
